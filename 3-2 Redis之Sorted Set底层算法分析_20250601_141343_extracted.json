["大家好", "接下来我们就把 short set 有序集合", "它的内部数据结构给大家详细的讲解一下", "我们先来看一下有序集合这四个字的字面意思啊", "那我们脑海里边的印象就是，我这有个容器", "容器里边呢，都已经排好序了", "那无非就是快速的查找和插入呗", "不管你是查找还是插入", "最终肯定是要确定那个位置", "那么最简单的办法就是从最开头开始", "最终找到我们的位置", "挨个儿比较", "但是这个实际上在数据集比较大的时候", "它的性能就会比较低了", "它的时间复杂度是 ON ", "有没有什么可提升这个性能的办法呢", "当然是有的", "那么很多人肯定也都知道", "比如说用二分折半是吧", "那我们就来说一下啥是二分", "啥是折半", "把这些概念的东西都给大家讲一讲", "说到这个二分呢", "其实二分他就是在一个有序的集合中", "把这个首尾呢进行相加除以二", "得到一个中间索引", "拿着中间索引的值", "和我们的目标元素来进行比较", "比较完之后看看是比它大还是比他小", "比如说比它小", "那就在左右两边呢", "比它大，那就在右边去找", "从左边去找", "比如说现在就比他小吧", "在左边找", "把左边再做一次", "首尾相加除以又得到一个左右两部分", "如此反复", "一直到找到我们的目标元素", "它的时间复杂度就是 OON ", "只要优效于我们直接去查找的", "那我们来看一下这个二分查找啊", "它具体的一个过程是什么样子的", "我这儿呢，给大家准备了一个动图", "把这个过程完善了一下", "比如说现在我这里有一个有序的容器", "它的起始索引是零", "它的末尾索引是九", "那么零就是咱们的最低位了", "九就是我们的最高位", "首尾相加除以二", "取整之后", "我们得到一个中间位，14", "中间为四", "索引上的值是28", "28和22相比较", "28大于22", "并且呢，我们也知道了", "28已经大于22了", "那还有必要参与后面的运算吗", "没有必要", "所以说我们就从中间位的索引上减一", "为啥要减一啊", "因为28都已经大于它了", "那五、六、七这些索引肯定都不是我们要找的", "我们是不是要从左半部分去找", "所以说4-1", "最后我们得到最高位的索引", "现在就变成三了", "那我们就在0~3这个区间内去找", "然后首尾相加除以二", "得到中间索引是一", "再来看15是小于22的", "但我们都知道它小于22的", "还有必要参与运算吗", "没有对中间位做加一的操作", "为什么是加一呢", "因为中间位都小于22了", "它左半部分的是不是都全部小于22", "所以说就右走", "那么中间位加一", "我们现在得到它的起始", "所以呢，就是二", "那么相当于就是最低位现在是二", "最高位是三", "然后我们得到一个中间位是二", "继续运算", "18是小于22的", "再来让中间位做一个增 in 加一", "那么就变成三了", "现在最低位也是三", "最高位也是三", "中间位是不是就是三", "22和我们的最终要找的这个值", "中间位置三", "22相比较相等", "查找成功", "这就是一次二分查找的一个完整的过程", "那为了让大家呢", "更深刻的去思考啊", "我给你们留了一个作业", "这个需要大家课后呢，独立完成", "就是在这个有序的容器里边", "去把45这个值给我找到", "那我们通过肉眼下来看一下", "有这个值吗", "没有，最终结果是啥", "查找失败", "但是我需要你们去画图分析", "完成这个查找过程", "如果有疑问的话", "或者说遇到问题", "那么就在评论讨论区里面留言", "我后续呢，会给大家一一的解答", "那么说完了二分查找说老师", "那我们难道在 short set 里边", "来快速的实现插入和读取的吗", "就是用这个二分查找", "当然不是", "因为二分查找它有一个限制", "必须是有序的数组", "而我们的 shorted set 实际上他用的是链表", "那么链表中怎么去找呢", "又回到原始了", "我们可以挨个去比较啊", "那么挨个儿比较时间复杂度", "o on 怎么提升呢", "又不能用二分", "于是呢，就产生了一种新的数据结构", "叫做跳跃列表。 skip list ", "它的原理是什么呢", "我解释一下", "它实际上就是多层链组成的", "比如说最底下的是咱们的原始链表", "然后呢，我把原始列表里边的这每一个节点啊", "就你现在看到的12、23、26这每一个节点", "note 给它做随机的节点升级", "比如说我现在就把23 L 级了", "34也升级了", "我是不是就又构建出一个列表", "31 L 级", "这个列表是咱们原始链表的子集", "你可以理解为就是它的一个索引", "然后比如说我想要实现快速查找的话", "我可以再升级", "我把31又升级了", "现在得到了第二层索引", "那我再来一级", "那我们的 shorty set 总共有这么几层啊", "四层就是它加上原始链表", "原始链表其实也算一层", "对不对", "他是 label 0", "然后第一集呢，就是 LAL 1、 level 2、 level 3", "我们的 short set 内部就是这样的一个四层的跳跃表组成的", "那你现在看到的这每一个节点", "就这个12、23、26", "浅黄色部分实际上就是 s score ", "咱们 shy set 是不是有一个思考的属性", "我刚才都说过", "他是用 SSC 来做排序的", "是一个权重的属性", "这个12、23就是思考右半部分", "浅蓝色就是咱们存进去的 value ", "就是咱们的 value 对象 V 6的值", "好，那么这个节点是怎么升级的呢", "它内部有一个随机的算法", "这个随机的算法是概率性的", "这个作者是在90年发表的这篇论文", "就是跳入列表的论文", "他的论文里边说是根据概率性", "然后做节点", "做随机的升级", "你可以理解为就像抛硬币一样", "以这样的一种随机概率来做升级", "所以说这里边也会有一个小插曲", "什么插曲？就是作者在论文里面说了", "他经过了大量的测试之后", "发现有极少部分情况下会出现 ON 的情况", "就时间复杂度 ON ", "什么意思啊", "就是这个节点升级", "如果说处理的不是特别好的情况下", "就极少部分的情况下会趋向于 ON ", "但是大部分情况都是 o log ", "这是他自己的一个测试", "所以说这部分我们就给大家来简单的说明一下", "那么在咱们的跳跃列表里边", "我们是如何去找的呢", "它是从最顶层开始找的", "然后呢，找不到回来就往下走", "一直走、一直走、一直走", "最终到原始链表", "然后找到我们的值", "或者说没有找到查找失败", "那我们就详细的给大家呢", "再来把这个过程说一下", "我们刚才看到的这每一个链表", "就包括我们的原始链表", "和上层构建出来的这些索引列表", "它每一个都是从负无穷大到正无穷大", "就你看到的这里边的这些思考", "从负无穷大开始一直到正无穷大", "然后呢，它内部做了一个排序", "然后现在呢，假如说我呢", "要去快速的查找和插入", "他其实内部呢，自己会根据概率型算法先升级", "升级之后呢", "我们现在要去处理", "要去找的话", "那就是从最顶层开始", "比如说现在呢，我要去找", "那就从最上层、最底层开始找", "然后找不到", "往下就是找不到的话", "我就往下走", "第三层索引，从负无穷大到正无穷大", "找不到。到第二层索引", "这个负无穷大我们暂且把它定义为 P ", "这个正无穷大我们暂且把它定义为 Q ", "然后我们有一个正无穷大的值", "我们用 Y 来定义一下", "比如说 Y 等于正无穷大", "现在假设我们要去找78这个值", "78从负无穷大开始找到正无穷大", "我现在所说的这个值实际上就指的是死 call 啊", "比如说我们现在的这个 score 是78", "正无穷大是不是肯定是大于这个78的", "我要去找他", "所以说它就会返回", "对不对", "然后呢，向下走，向下走", "然后就开始到26这个思考", "到26发现26是小于78的", "那么就继续往右到31", "前提条件是要有啊", "如果没有就往下了", "到31", "31再往右到正无穷大", "正无穷大是不是大于78", "那么就回来就继续往下了", "比如说一直一直往下到原始链表", "到原始列表之后", "咱们最终的目标不是找那个78吗", "相当于就会找到了", "如果说我们找的是79呢", "那就查找失败", "找不到", "就这样的一个逻辑给大家呢", "把这个完整的查找过程复现一下啊", "我这里构建了四层链表", "原始链表加上三层索引", "假如说现在我就要去找78", "从最顶层开始", "首先是负无穷大到正无穷大", "找到这个死靠", "发现正无穷大大于78", "返回往下走下来了", "下来之后呢", "直接的跳到31", "因为它是跳跃表嘛", "它相当于把十、二、13、26是不是直接就过滤掉了", "跳到30", "跳到31之后", "发现31小于78", "是不是啊", "那么就继续往右到正无穷大", "这个思考", "正无穷大大于78", "返回继续往下", "然后同样的31小于78", "跳到34", "34小于78", "跳到64", "64小于78", "然后它向右边是不是还有啊", "到正无穷大", "正无穷大是不是大于78", "好，回来往下", "往下继续呢", "64小时七八继续到78", "然后78是不是等于我们最终要找到这个 SCORD 78", "这就相当于查找到了", "如果说咱们找的是79、80", "你看他往右是到正无穷大", "正无穷呢，没找到呀", "回来往下还能下，下不了了", "怎么办", "这已经是原始列表了", "最终会查找失败", "这就是跳跃列表的一个完整的查找过程", "也就是咱们 redis short set 内部的一个结构", "然后我也给大家讲清楚了", "就是我们 redis short set ", "其实它那个链表啊", "每一个节点都是两部分组成", "一部分就是我们的 score 分数排序用的权重", "另外一部分就是咱们存的 value 的值", "然后它实际上是一个 zip list ", "就是压缩列表", "那可能有人想问", "就为什么不用红黑树、平衡树来实现呢", "为什么要用跳跃列表", "首先跳二列表", "红黑树平衡数", "它们最终的时间复杂度都是 o log n ", "就是它们的性能都是一样的", "但是从源码上去出发的话", "跳跃列表的实现是完全要简单于", "红黑树和平衡树的 REDIS 作者", "他在构建这个 sht set 时候", "他也会去思考", "那我如果用红黑树、平衡树", "我自己去写这个源码的过程中", "可能会比较复杂", "是不是考虑到他要开源后续呢", "可能很多人要过来看源码学习", "他就用了相对于简单的跳跃列表 skip list", "来实现整个过程", "但是它的性能又没有降低", "还是跟红黑树、平衡树是一样的", "这就是关于咱们整个跳跃列表 skip list", "我们就说到这里", "所有的内容", "3-2 Redis之Sorted Set底层算法分析"]