1
00:00:00,000 --> 00:00:01,240
各位同学，大家好啊

2
00:00:01,240 --> 00:00:04,460
这个小节的内容我们来学习

3
00:00:04,460 --> 00:00:05,580
ino db 

4
00:00:05,580 --> 00:00:07,510
在更新的过程中

5
00:00:07,510 --> 00:00:08,990
有三个重要的问题

6
00:00:08,990 --> 00:00:11,050
我们上节课说过对吧

7
00:00:11,050 --> 00:00:12,650
第一个问题就是日志

8
00:00:12,650 --> 00:00:15,870
我们来学习一下 MYSQL 的日志体系啊

9
00:00:15,870 --> 00:00:21,050
MYSQL 为了满足比如说主从复制事物的功能

10
00:00:21,050 --> 00:00:24,230
它有比较复杂的日志体系

11
00:00:24,230 --> 00:00:25,950
上一小节我们也说了

12
00:00:25,950 --> 00:00:29,200
这个日志不是给人看的那种日志

13
00:00:29,200 --> 00:00:33,420
而是系统运行所需要的日志

14
00:00:33,420 --> 00:00:35,020
是给系统看的

15
00:00:35,020 --> 00:00:37,000
是给软件看的啊

16
00:00:37,100 --> 00:00:39,440
那 MYSQL 都有哪些日志呢

17
00:00:39,440 --> 00:00:43,360
我相信大家如果之前啊，了解过 MYSQL 的话

18
00:00:43,360 --> 00:00:45,120
肯定多少能听说过啊

19
00:00:45,120 --> 00:00:47,270
比如第一个 blog 对吧

20
00:00:47,270 --> 00:00:50,030
VLOG 呢，是 server 层产生的啊

21
00:00:50,030 --> 00:00:53,730
也就是说，不管咱们用什么存储引擎啊

22
00:00:53,730 --> 00:00:57,060
不管是 ino dB 啊、 my issum 呀、 memory 啊

23
00:00:57,060 --> 00:01:00,900
都会出现 blog 这种日志

24
00:01:00,900 --> 00:01:04,000
这种日志主要是记录原本的

25
00:01:04,000 --> 00:01:07,960
记录系统数据更新的情况啊

26
00:01:07,960 --> 00:01:12,580
那 blog 最大的作用就是用来数据复制

27
00:01:12,580 --> 00:01:17,720
也就是说 blog 传送给重机或者备库的时候

28
00:01:17,720 --> 00:01:22,320
被库会用 blog 来重现主库的数据更新

29
00:01:23,430 --> 00:01:26,030
第二个呢，是这个 ino dB 啊

30
00:01:26,030 --> 00:01:29,440
产生的 undo log 和 redo log 

31
00:01:29,440 --> 00:01:32,440
这两个 log 呢，是印度 dB 产生的

32
00:01:32,440 --> 00:01:35,090
跟别的存储引擎就没关系了啊

33
00:01:35,090 --> 00:01:36,730
跟 server 层也没关系了

34
00:01:36,730 --> 00:01:40,390
所以说 undo log 和 redo log 是 inno dB 特有的

35
00:01:40,390 --> 00:01:41,310
也就是说

36
00:01:41,310 --> 00:01:42,590
比如说有人

37
00:01:42,590 --> 00:01:44,210
undo log 和 redo log 

38
00:01:44,210 --> 00:01:46,430
是不是 MYSQL 必须有的 log 

39
00:01:46,430 --> 00:01:47,630
它不一定有

40
00:01:47,630 --> 00:01:51,090
只有他用 ino dB 这个存储引擎的时候也有

41
00:01:51,090 --> 00:01:52,250
那么 INODI 呢

42
00:01:52,250 --> 00:01:54,770
主要是用 undo log 和 redo lo

43
00:01:54,770 --> 00:01:56,330
用来实现事物啊

44
00:01:56,330 --> 00:01:57,610
用来实现事物

45
00:01:57,610 --> 00:01:59,960
那 MYSQL 的日志体系

46
00:01:59,960 --> 00:02:01,600
它主要不是用来看的啊

47
00:02:01,600 --> 00:02:03,000
尤其是这几个日志啊

48
00:02:03,000 --> 00:02:04,800
它有用来给人看的日志

49
00:02:04,800 --> 00:02:06,280
但是不是这几个

50
00:02:06,280 --> 00:02:09,770
这几个是运行所必要的日志

51
00:02:09,770 --> 00:02:12,700
我们把这三种啊

52
00:02:12,700 --> 00:02:15,580
主要这三种日志再详细的啊

53
00:02:15,580 --> 00:02:17,380
跟带领大家一块研究一下

54
00:02:17,380 --> 00:02:18,890
第一个， blog 

55
00:02:18,890 --> 00:02:22,550
blog 它的中文名叫归档日志啊

56
00:02:22,550 --> 00:02:24,370
归档日志。大家一听啊

57
00:02:24,370 --> 00:02:27,770
这个归档的意思大概就明白了啊

58
00:02:27,770 --> 00:02:32,150
首先它是 server 层产生的逻辑日志

59
00:02:32,150 --> 00:02:34,000
什么叫逻辑日志呢

60
00:02:34,000 --> 00:02:38,460
就是它只记录了这个数据应该怎么变化

61
00:02:38,460 --> 00:02:41,760
它并没有记录这个物理的数据页

62
00:02:41,760 --> 00:02:42,980
具体怎么变

63
00:02:42,980 --> 00:02:44,220
它是逻辑的啊

64
00:02:44,220 --> 00:02:45,100
逻辑的

65
00:02:45,100 --> 00:02:48,070
它主要用来进行数据的复制

66
00:02:48,070 --> 00:02:49,370
数据的传送

67
00:02:49,370 --> 00:02:52,900
有些时候用来进行数据的备份

68
00:02:52,900 --> 00:02:56,750
和数据的这个闪回啊

69
00:02:56,750 --> 00:02:59,610
为什么能做数据的备份和闪回呢

70
00:02:59,610 --> 00:03:02,450
因为 blog 它是完整记录了数据库的

71
00:03:02,450 --> 00:03:04,530
每次数据操作

72
00:03:04,530 --> 00:03:07,440
你可以把它理解为数据审计

73
00:03:07,440 --> 00:03:08,700
操作。审计

74
00:03:08,700 --> 00:03:13,000
反正他就是一个完美的完整记录

75
00:03:13,000 --> 00:03:15,060
数据库操作的手段

76
00:03:15,060 --> 00:03:16,560
只要我们有这种手段

77
00:03:16,560 --> 00:03:18,550
我们就可以用 blog 做干嘛呀

78
00:03:18,550 --> 00:03:19,610
做备份对吧

79
00:03:19,610 --> 00:03:21,210
我们把 blog 都备份下来

80
00:03:21,210 --> 00:03:24,000
那就记录好了数据库的数据操作，对吧

81
00:03:24,000 --> 00:03:25,470
或者是做什么

82
00:03:25,470 --> 00:03:27,630
做主从复制，对吧

83
00:03:27,630 --> 00:03:30,370
我把 blog 传送给从机啊

84
00:03:30,370 --> 00:03:31,500
这样的话呢

85
00:03:31,500 --> 00:03:34,860
重击就能跟主机一样被操作，对吧

86
00:03:34,860 --> 00:03:37,300
还可以作为数据闪回的手段

87
00:03:37,300 --> 00:03:40,350
因为 blog 记录了哪一刻、哪一秒

88
00:03:40,350 --> 00:03:42,260
我对数据库做了什么操作

89
00:03:42,260 --> 00:03:44,070
那我根据这个 blog 

90
00:03:44,070 --> 00:03:46,110
是不是就跟这个录像带倒带一样

91
00:03:46,110 --> 00:03:48,270
我就可以跟时间倒流一样啊

92
00:03:48,270 --> 00:03:50,680
可以把这个数据库的状态给退回

93
00:03:50,680 --> 00:03:51,640
往回推

94
00:03:51,640 --> 00:03:53,580
这样的话可以作为，对吧

95
00:03:53,580 --> 00:03:55,360
像时光机一样的啊

96
00:03:55,360 --> 00:03:59,050
数据库数据闪回 blog 呢

97
00:03:59,050 --> 00:04:02,690
它记录在专门的文件当中啊

98
00:04:02,690 --> 00:04:05,780
这个到了我们第六章节

99
00:04:05,780 --> 00:04:07,610
就是研究备份的时候

100
00:04:07,610 --> 00:04:10,620
我们会进一步使用这个 blog 啊

101
00:04:10,620 --> 00:04:12,060
d log 讲完了啊

102
00:04:12,060 --> 00:04:13,300
那是 server 层的啊

103
00:04:13,300 --> 00:04:16,000
后面的还有两个主要的 log 

104
00:04:16,000 --> 00:04:17,300
它是印度 dB 

105
00:04:17,300 --> 00:04:19,310
还有存储引擎产生的啊

106
00:04:19,310 --> 00:04:20,810
第一个 undo log 

107
00:04:20,810 --> 00:04:24,750
undo log 是印度 dB 产生的这个逻辑日志啊

108
00:04:24,750 --> 00:04:27,660
它的中文名一般叫回滚日志

109
00:04:27,660 --> 00:04:29,600
因为你看它的英文 on do 嘛

110
00:04:29,600 --> 00:04:33,490
就是相当于 CTRL 加 Z 撤销的意思啊

111
00:04:33,490 --> 00:04:36,040
就相当于是撤销日字日志

112
00:04:36,040 --> 00:04:38,880
这个撤销日志或者回滚日志

113
00:04:38,880 --> 00:04:40,780
它是干什么用的呢

114
00:04:40,780 --> 00:04:45,700
它用来事故的回滚和展示旧版本这两个作用

115
00:04:45,700 --> 00:04:47,060
为什么是这两个作用

116
00:04:47,060 --> 00:04:49,290
第一事务的回滚

117
00:04:49,290 --> 00:04:52,500
也就是说这个事物我看更新了几十条数据

118
00:04:52,500 --> 00:04:55,140
但是最后我这个事物要 roll back ，对吧

119
00:04:55,140 --> 00:04:56,340
我不 commit 了

120
00:04:56,340 --> 00:04:58,480
这个时候就要使用 undo log 

121
00:04:58,480 --> 00:05:01,720
把前面干的那些活全部都还原回去啊

122
00:05:01,720 --> 00:05:02,340
还原回去

123
00:05:02,340 --> 00:05:04,500
这就 undo log 就起作用了

124
00:05:04,500 --> 00:05:07,270
展示旧版本的呢，是在 MVCC 

125
00:05:07,270 --> 00:05:09,550
也就是多版本并发控制的时候用这个

126
00:05:09,550 --> 00:05:11,540
我们后面的小节会详细的讲

127
00:05:11,540 --> 00:05:14,350
对于任何数据或者缓存的更新

128
00:05:14,350 --> 00:05:17,020
都要先写 undo log 

129
00:05:17,020 --> 00:05:18,550
也就是说在印度 dB 啊

130
00:05:18,550 --> 00:05:20,750
我们使用印度 dB 事务的情况下

131
00:05:20,750 --> 00:05:24,070
undo log 是个必须有的组件啊

132
00:05:24,070 --> 00:05:25,340
或者必须有的功能

133
00:05:25,340 --> 00:05:26,520
它更新数据的时候

134
00:05:26,520 --> 00:05:29,760
必须要写 undo log 来满足它事物的功能

135
00:05:29,760 --> 00:05:34,080
undo log 位于表空间的 undo segment 啊

136
00:05:34,080 --> 00:05:37,000
也就是说大家还记得我们那个空间下面分段

137
00:05:37,000 --> 00:05:37,360
对吧

138
00:05:37,360 --> 00:05:40,480
分段有专门的 undo segment 段啊

139
00:05:40,480 --> 00:05:43,420
是放在这个表空间里面的

140
00:05:43,740 --> 00:05:49,690
我们来模拟一下 undo log 的所谓的逻辑日志

141
00:05:49,690 --> 00:05:51,240
大概是个什么样啊

142
00:05:51,240 --> 00:05:53,040
它物理上不这样存的

143
00:05:53,040 --> 00:05:54,520
但是为了帮助大家理解

144
00:05:54,520 --> 00:05:55,520
它大概是这个样的

145
00:05:55,520 --> 00:05:57,490
比如说我写了一个 SQL 语句

146
00:05:57,490 --> 00:05:59,560
update 一个字段等于 B 吧

147
00:05:59,560 --> 00:06:00,740
它原来是 A 啊

148
00:06:00,740 --> 00:06:02,340
update 一个字段等于 B 

149
00:06:02,340 --> 00:06:04,240
undo log 应该怎么记呢

150
00:06:04,240 --> 00:06:06,610
继承它的相反作用

151
00:06:06,610 --> 00:06:09,100
反作用就是 update name 等于 A 

152
00:06:09,100 --> 00:06:11,660
就是把它原来是 A 更新成 B 

153
00:06:11,660 --> 00:06:16,060
这个时候我们记一条从 B 还原为 A 的 undo log 

154
00:06:16,060 --> 00:06:17,860
这个就叫回滚日志

155
00:06:17,860 --> 00:06:20,910
不是记录回滚情况的日志

156
00:06:20,910 --> 00:06:24,110
而是需要回滚的时候用的日志

157
00:06:24,110 --> 00:06:25,290
叫回滚日志啊

158
00:06:25,290 --> 00:06:26,440
这是 undo 啊

159
00:06:26,440 --> 00:06:27,430
那么再下一个呢

160
00:06:27,430 --> 00:06:29,690
就是 in 度 dd 里面啊

161
00:06:29,690 --> 00:06:32,690
重要性最高的一个 log 叫 redo log 

162
00:06:32,690 --> 00:06:33,430
redo log 

163
00:06:33,430 --> 00:06:36,590
你从英文上啊，大概就能判断出来它叫什么

164
00:06:36,590 --> 00:06:39,090
重做日志是干嘛的呢

165
00:06:39,090 --> 00:06:41,220
是印度 dB 产生的啊

166
00:06:41,220 --> 00:06:42,220
物理日志

167
00:06:42,220 --> 00:06:43,800
大家注意，这是物理日志

168
00:06:43,800 --> 00:06:47,560
它的内容就是数据页的变化

169
00:06:47,560 --> 00:06:48,820
数据页是什么

170
00:06:48,820 --> 00:06:49,800
大家还记得吗

171
00:06:49,800 --> 00:06:50,880
前面讲过对吧

172
00:06:50,880 --> 00:06:52,840
数据页就是 ino d

173
00:06:52,840 --> 00:06:55,570
B 加树的叶子节点

174
00:06:55,570 --> 00:06:57,750
或者是它的索引节点

175
00:06:57,750 --> 00:07:01,510
那这个节点里面记录着数据本身，对吧

176
00:07:01,510 --> 00:07:04,070
所以说记录数据页的变化

177
00:07:04,070 --> 00:07:06,830
就是对于尼诺 dB 数据

178
00:07:06,830 --> 00:07:09,700
物理存储的一个物理日志

179
00:07:09,700 --> 00:07:13,060
那么 ino dB 一直是啊

180
00:07:13,060 --> 00:07:17,920
遵循日志优先于数据的这个逻辑

181
00:07:17,920 --> 00:07:20,120
也就是说我写了日志

182
00:07:20,120 --> 00:07:23,740
这里说的写日志是写的 redo log 

183
00:07:23,740 --> 00:07:26,610
也就是说我只要既写了 redo log 

184
00:07:26,610 --> 00:07:29,480
就视为数据已经更新了

185
00:07:29,480 --> 00:07:30,510
这是什么意思

186
00:07:30,510 --> 00:07:32,450
我给大家讲打一个比方啊

187
00:07:32,450 --> 00:07:35,190
比如说你在跟老板开会

188
00:07:35,190 --> 00:07:36,710
你在跟老板讲一个

189
00:07:36,710 --> 00:07:38,830
你做了两个礼拜的 PPT 啊

190
00:07:38,830 --> 00:07:40,810
这个 PPT 有80页对吧

191
00:07:40,810 --> 00:07:42,900
你跟老板开会讲讲讲讲

192
00:07:42,900 --> 00:07:44,930
比如说你讲到第53页

193
00:07:44,930 --> 00:07:46,270
这个时候老板说

194
00:07:46,270 --> 00:07:48,050
哎，停这个地方停一下啊

195
00:07:48,050 --> 00:07:49,000
比如说啊

196
00:07:49,000 --> 00:07:50,670
比如我们这个 PPT 

197
00:07:50,670 --> 00:07:52,110
就是你做的这个 PPT 

198
00:07:52,110 --> 00:07:54,150
老板说这个逗号不对啊

199
00:07:54,150 --> 00:07:56,970
这个逗号应该用句号

200
00:07:56,970 --> 00:08:00,080
请问这个时候你是把 PPT 退出来

201
00:08:00,080 --> 00:08:02,110
然后把逗号改成句号

202
00:08:02,110 --> 00:08:03,090
接着说呢

203
00:08:03,090 --> 00:08:05,110
还是拿小本本写上

204
00:08:05,110 --> 00:08:07,140
老板说了48页用逗号

205
00:08:07,140 --> 00:08:08,560
逗号要改成句号了

206
00:08:08,560 --> 00:08:11,060
一般来讲你要做第二种对吧

207
00:08:11,060 --> 00:08:12,500
只是记个小本本

208
00:08:12,500 --> 00:08:13,310
为什么呢

209
00:08:13,310 --> 00:08:16,590
因为这个时候大家都在等着你往下讲，对吧

210
00:08:16,590 --> 00:08:19,510
你现在现改的话也来不及啊

211
00:08:19,510 --> 00:08:22,340
所以说只要记上小本本就可以了

212
00:08:22,340 --> 00:08:23,960
这样的话，你到了下面

213
00:08:23,960 --> 00:08:25,040
你完事之后

214
00:08:25,040 --> 00:08:27,790
你回去再改这个地方的小本本

215
00:08:27,790 --> 00:08:30,290
你记的东西就叫 redo log 

216
00:08:30,290 --> 00:08:33,909
也就是说印度 dB 日志优先于数据

217
00:08:33,909 --> 00:08:37,049
就是说记了 log 等于记了数据

218
00:08:37,049 --> 00:08:39,510
记了 log 你早晚会记数据

219
00:08:39,510 --> 00:08:41,580
这个小本本记上这个东西要改

220
00:08:41,580 --> 00:08:42,640
你早晚会改

221
00:08:42,640 --> 00:08:44,520
只是你早改和晚改的问题

222
00:08:44,520 --> 00:08:47,460
你把这个要修改的意见记了小本本

223
00:08:47,460 --> 00:08:50,220
老板就认为你这个东西已经更新了

224
00:08:50,220 --> 00:08:51,200
你早晚会更新

225
00:08:51,200 --> 00:08:55,220
这是印度 dB 日志优先于数据的意思啊

226
00:08:55,220 --> 00:08:58,580
那么这个内存中的数据更新之后

227
00:08:58,580 --> 00:09:00,280
是写 redo log 啊

228
00:09:00,280 --> 00:09:03,280
数据被写入硬盘之后删除

229
00:09:03,280 --> 00:09:04,030
什么意思啊

230
00:09:04,030 --> 00:09:07,110
内存中的数据是内存中的数据页是吧

231
00:09:07,110 --> 00:09:09,070
INODBB 加数的数据页

232
00:09:09,070 --> 00:09:11,970
为什么这个 B 加数的数据页会在内存中呢

233
00:09:11,970 --> 00:09:14,120
因为我们在查询数据

234
00:09:14,120 --> 00:09:15,140
修改数据的时候

235
00:09:15,140 --> 00:09:17,420
是不是先把数据查出来，对吧

236
00:09:17,420 --> 00:09:18,100
查出来之后

237
00:09:18,100 --> 00:09:20,360
这个数据页就在内存当中改

238
00:09:20,360 --> 00:09:23,690
就直接改的是内存当中的这个数据页

239
00:09:23,690 --> 00:09:26,270
改完之后写 redo log 

240
00:09:26,270 --> 00:09:26,970
这个时候

241
00:09:26,970 --> 00:09:30,510
这个内存中的数据页是不写回硬盘的

242
00:09:30,510 --> 00:09:32,210
是不写回硬盘的

243
00:09:32,210 --> 00:09:34,970
这个数据什么时候删了

244
00:09:34,970 --> 00:09:38,150
是被写入硬盘之后删掉

245
00:09:38,150 --> 00:09:41,660
就 redo log 被写入硬盘之后是删掉了

246
00:09:41,660 --> 00:09:46,180
redo log 是存储在四个1 GB 的文件当中啊

247
00:09:46,180 --> 00:09:47,580
这个1 GB 是可以配置的

248
00:09:47,580 --> 00:09:49,820
并且循环写入

249
00:09:49,820 --> 00:09:52,770
我们看一下它所谓的循环写入啊

250
00:09:52,770 --> 00:09:53,770
是个什么含义

251
00:09:53,770 --> 00:09:56,330
大家看，这里是四个 redo log 文件

252
00:09:56,330 --> 00:09:58,060
四个 redo log 文件

253
00:09:58,060 --> 00:10:01,500
这里有个 right position 和 checkpoint 啊

254
00:10:01,500 --> 00:10:02,460
四个文件

255
00:10:02,460 --> 00:10:05,520
我们把这张图缩小一下啊

256
00:10:05,530 --> 00:10:08,950
这 checkpoint red position 是吧

257
00:10:08,950 --> 00:10:10,390
四个文件它有什么

258
00:10:10,390 --> 00:10:11,470
两个箭头来看

259
00:10:11,470 --> 00:10:13,820
有个方向箭头是干什么用的呢

260
00:10:13,820 --> 00:10:17,610
首先， red position 是当前日志写入点啊

261
00:10:17,610 --> 00:10:19,010
这是当前日志写入点

262
00:10:19,010 --> 00:10:23,460
也就是说上面绿色的部分是空白的啊

263
00:10:23,460 --> 00:10:24,880
空白的这个文件啊

264
00:10:24,880 --> 00:10:25,760
文件是空白的

265
00:10:25,760 --> 00:10:29,620
下面黄色的是有用的文件啊

266
00:10:29,620 --> 00:10:32,560
记录的东西的文件是老板告诉你

267
00:10:32,560 --> 00:10:34,000
这个逗号要改成句号

268
00:10:34,000 --> 00:10:35,540
它具体的内容啊

269
00:10:35,540 --> 00:10:38,250
就你记得这个这个日志啊

270
00:10:38,250 --> 00:10:39,410
在这个地方

271
00:10:39,410 --> 00:10:43,420
好，那 red position 就是当前写入点

272
00:10:43,420 --> 00:10:45,700
比如说你的另一个同事又给你提意见了

273
00:10:45,700 --> 00:10:46,780
说你这个 PPT 啊

274
00:10:46,780 --> 00:10:48,780
这个地方又少个句号了啊

275
00:10:48,780 --> 00:10:50,620
你就再往前写一条啊

276
00:10:50,620 --> 00:10:51,540
这个第多少

277
00:10:51,540 --> 00:10:52,540
这是第七页啊

278
00:10:52,540 --> 00:10:55,070
第七页要加上一个句号

279
00:10:55,070 --> 00:10:57,770
这个地方这个 red position 就会又往前推

280
00:10:57,770 --> 00:10:59,470
你这个地方黄色的就会增加

281
00:10:59,470 --> 00:11:01,510
为什么你又，你又写新的日志了

282
00:11:01,510 --> 00:11:03,470
你又写新的 redo log 了啊

283
00:11:03,470 --> 00:11:04,250
是这样的

284
00:11:04,250 --> 00:11:06,310
这个 checkpoint 啊，在这啊

285
00:11:06,310 --> 00:11:09,360
checkpoint 这个地方是擦除点

286
00:11:09,360 --> 00:11:12,610
数据被更新到硬盘时擦除

287
00:11:12,610 --> 00:11:14,350
也就是说，比如这个地方啊

288
00:11:14,350 --> 00:11:15,510
是你前面啊

289
00:11:15,510 --> 00:11:16,750
就是你同事啊

290
00:11:16,750 --> 00:11:18,350
老板给你提了很多条意见

291
00:11:18,350 --> 00:11:19,350
你写的这个报告

292
00:11:19,350 --> 00:11:20,450
或者你做了个 PPT 

293
00:11:20,450 --> 00:11:21,920
然后这个地方啊

294
00:11:21,920 --> 00:11:23,330
就是你回来之

295
00:11:23,330 --> 00:11:24,890
你一条一条的改啊

296
00:11:24,890 --> 00:11:25,970
比如说这一条是啊

297
00:11:25,970 --> 00:11:27,120
有的同学说啊

298
00:11:27,120 --> 00:11:27,920
有同事说啊

299
00:11:27,920 --> 00:11:29,300
你这一页这个图太小

300
00:11:29,300 --> 00:11:30,780
回去要调大一点，好

301
00:11:30,780 --> 00:11:32,460
你回去就吭哧吭哧改

302
00:11:32,460 --> 00:11:33,900
改完之后这一条啊

303
00:11:33,900 --> 00:11:35,000
记在这的这一条

304
00:11:35,000 --> 00:11:36,770
这个 log 用完了啊

305
00:11:36,770 --> 00:11:38,910
改完了这个 PPT 已经改完了

306
00:11:38,910 --> 00:11:40,150
这条就是用不掉了

307
00:11:40,150 --> 00:11:40,930
把它擦掉

308
00:11:40,930 --> 00:11:44,350
擦掉之后这个绿色的部分就是它空白的部分

309
00:11:44,350 --> 00:11:45,750
是不是往下走了，对吧

310
00:11:45,750 --> 00:11:48,280
所以说这个地方叫擦触点啊

311
00:11:48,280 --> 00:11:52,000
随着这个 redo log 被更新到数据页上啊

312
00:11:52,000 --> 00:11:54,680
被更新到硬盘里的数据页上

313
00:11:54,680 --> 00:11:55,970
这个 redo log 啊

314
00:11:55,970 --> 00:11:58,650
文件里面的 redo log 会越来越少

315
00:11:58,650 --> 00:12:01,050
那又随着别人在不断的更新

316
00:12:01,050 --> 00:12:02,660
不断的跑事务

317
00:12:02,660 --> 00:12:05,220
这个 redo log 会越来越多

318
00:12:05,220 --> 00:12:06,120
会越来越多

319
00:12:06,120 --> 00:12:08,000
所以它保持着一种平衡

320
00:12:08,000 --> 00:12:09,780
就 checkpoint 往下转

321
00:12:09,780 --> 00:12:11,700
red position 往上转啊

322
00:12:11,700 --> 00:12:13,930
都是在顺时针的转啊

323
00:12:13,930 --> 00:12:15,630
这个地方不是一个圈

324
00:12:15,630 --> 00:12:17,330
它是四个文件

325
00:12:17,330 --> 00:12:18,510
零一、零二、零三、零四

326
00:12:18,510 --> 00:12:20,190
在磁盘上就是四个文件

327
00:12:20,190 --> 00:12:21,190
在操作系统里

328
00:12:21,190 --> 00:12:23,320
你就能看到四个文件内部是这样

329
00:12:23,320 --> 00:12:24,540
它逻辑的连在一起

330
00:12:24,540 --> 00:12:26,720
它实际上在这个磁盘上

331
00:12:26,720 --> 00:12:28,660
并不是连在一起的啊

332
00:12:28,660 --> 00:12:32,960
好，那么可能会产生一些什么意外情况呢

333
00:12:32,960 --> 00:12:35,190
就就是比如说你这个 PPT 啊

334
00:12:35,190 --> 00:12:36,980
你这个本本啊就四页这么多

335
00:12:36,980 --> 00:12:38,340
然后你上次开会啊

336
00:12:38,340 --> 00:12:39,570
大家提了一堆意见

337
00:12:39,570 --> 00:12:41,390
提这个经验都提到这了对吧

338
00:12:41,390 --> 00:12:42,850
然后这次又开会

339
00:12:42,850 --> 00:12:44,410
你前面都没改

340
00:12:44,410 --> 00:12:45,190
没改呢

341
00:12:45,190 --> 00:12:47,200
你这个积的问题越来越多

342
00:12:47,200 --> 00:12:50,100
然后你这个同事啊，提的这个问题

343
00:12:50,100 --> 00:12:51,540
又提了一大堆箭头

344
00:12:51,540 --> 00:12:52,980
就往上走走走走走

345
00:12:52,980 --> 00:12:55,360
所以你这个小本本马上就记满了

346
00:12:55,360 --> 00:12:56,780
记满了之后啊

347
00:12:56,780 --> 00:12:57,600
就记到这儿了

348
00:12:57,600 --> 00:12:59,360
请问如果你的同事再给

349
00:12:59,360 --> 00:13:00,780
再针对你的工作

350
00:13:00,780 --> 00:13:01,940
或者是你的报告

351
00:13:01,940 --> 00:13:03,560
或者你的 PPP 再提意见

352
00:13:03,560 --> 00:13:05,680
还能记到你的小本本上吗

353
00:13:05,680 --> 00:13:06,380
记不到了

354
00:13:06,380 --> 00:13:08,080
所以说你这个时候干嘛呀

355
00:13:08,080 --> 00:13:11,200
要强制他们停止对你提出意见

356
00:13:11,200 --> 00:13:12,460
也就是在数据库里面

357
00:13:12,460 --> 00:13:16,260
就强制别人停止对数据库的更新啊

358
00:13:16,260 --> 00:13:18,720
这样的话你要停下一段时间去干嘛

359
00:13:18,720 --> 00:13:21,230
把这些记录好的工作做一些

360
00:13:21,230 --> 00:13:22,120
做一些之后

361
00:13:22,120 --> 00:13:24,520
把你的小本本上空出来一部分啊

362
00:13:24,520 --> 00:13:26,880
才能继续接受别人的数据

363
00:13:26,880 --> 00:13:31,140
所以说，当这个 red position 追上 check point 的时候

364
00:13:31,140 --> 00:13:32,540
事物是无法提交的

365
00:13:32,540 --> 00:13:35,020
也就是说别人往数据库里增删

366
00:13:35,020 --> 00:13:36,000
查是可以查

367
00:13:36,000 --> 00:13:38,180
但增删改都干不了了

368
00:13:38,180 --> 00:13:40,660
需要等待我们这个 checkpoint 去推进

369
00:13:40,660 --> 00:13:42,350
就往下推进这个地方

370
00:13:42,350 --> 00:13:44,730
也就是说强制的刷 VLOG 

371
00:13:44,730 --> 00:13:47,050
也是这个更新的时候

372
00:13:47,050 --> 00:13:49,850
数据库性能差的一个源泉啊

373
00:13:49,850 --> 00:13:51,330
罪魁祸首之一啊

374
00:13:51,330 --> 00:13:55,670
就是说这个 checkpoint 往下走的太慢啊，太慢

375
00:13:55,670 --> 00:13:58,320
那么还是要强调上一页啊

376
00:13:58,320 --> 00:13:59,360
PPT 说的话

377
00:13:59,360 --> 00:14:01,880
只要 redo log 不丢数据就不会丢失

378
00:14:01,880 --> 00:14:06,420
我指的是已经落到这四个文件上的 redo log 

379
00:14:06,420 --> 00:14:06,940
也就是说

380
00:14:06,940 --> 00:14:09,770
只要是你把同事对你的意见

381
00:14:09,770 --> 00:14:13,940
老板对你的这个任务写到了你的笔记本上

382
00:14:13,940 --> 00:14:16,010
这个任务他就不会丢失

383
00:14:16,010 --> 00:14:17,550
你早晚会把它做了啊

384
00:14:17,550 --> 00:14:19,030
你不会忘掉它啊

385
00:14:19,030 --> 00:14:20,830
也就是这个原因啊

386
00:14:20,830 --> 00:14:23,530
只要 redo log 不丢数据就丢不了

387
00:14:23,530 --> 00:14:27,230
因为别人对于这个数据库的增删改

388
00:14:27,230 --> 00:14:29,630
就对数据库的新增啊

389
00:14:29,630 --> 00:14:30,750
删除和修改

390
00:14:30,750 --> 00:14:34,330
都被记录在了 redo log 这四个文件里面

391
00:14:34,330 --> 00:14:38,600
虽然现在数据库的数据还没有被改

392
00:14:38,600 --> 00:14:40,460
但它早晚会改的啊

393
00:14:40,460 --> 00:14:42,100
早晚会改的数据不会丢

394
00:14:42,100 --> 00:14:43,250
那有同学问

395
00:14:43,250 --> 00:14:45,890
我只把数据写在 redo log 里面

396
00:14:45,890 --> 00:14:49,390
那个硬盘上的数据它不是最新的

397
00:14:49,390 --> 00:14:50,720
别人查的时候

398
00:14:50,720 --> 00:14:52,690
别人查的时候是不是就查到旧的

399
00:14:52,690 --> 00:14:53,250
也不会

400
00:14:53,250 --> 00:14:55,690
因为这种我们写 redo log 这些数据

401
00:14:55,690 --> 00:14:57,470
它在内存里面了

402
00:14:57,470 --> 00:14:59,810
就他的数据页在内存有份新的

403
00:14:59,810 --> 00:15:00,530
你明白吗

404
00:15:00,530 --> 00:15:01,650
比如说老师啊

405
00:15:01,650 --> 00:15:03,410
把这个 PPT 啊

406
00:15:03,410 --> 00:15:04,890
退出播放模式啊

407
00:15:04,890 --> 00:15:06,750
领导让同老师改什么

408
00:15:06,750 --> 00:15:07,650
加个句号啊

409
00:15:07,650 --> 00:15:10,330
加了，加了之后这里没有保存

410
00:15:10,330 --> 00:15:11,050
明白吗

411
00:15:11,050 --> 00:15:12,570
磁盘上是旧的

412
00:15:12,570 --> 00:15:14,330
但是内存上是新的

413
00:15:14,330 --> 00:15:16,500
别人查的时候直接来查内存

414
00:15:16,500 --> 00:15:17,620
直接来查内存

415
00:15:17,620 --> 00:15:19,760
它和内存里面是新的数据

416
00:15:19,760 --> 00:15:22,060
只是没有持久化啊

417
00:15:22,060 --> 00:15:23,010
没有持久化

418
00:15:23,010 --> 00:15:25,000
持久化的是 redo log 

419
00:15:25,000 --> 00:15:28,060
但是数据早晚会持久化到硬盘里了

420
00:15:28,360 --> 00:15:31,660
好，这一小节的内容就到这里

421
00:15:31,660 --> 00:15:35,030
我们讲解了几种日志的作用

422
00:15:35,030 --> 00:15:35,990
那下一小节呢

423
00:15:35,990 --> 00:15:39,130
我们来讲解这个更新的 SQL 语句

424
00:15:39,130 --> 00:15:39,950
它的流程
