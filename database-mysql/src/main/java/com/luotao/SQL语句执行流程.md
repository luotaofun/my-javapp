## SQL语句执行流程

> "我们可以把这个过程想象成去图书馆借书。
>
> - 你（客户端）首先需要进入图书馆（连接器），找到借书窗口办理手续。
>
> - 你告诉工作人员（把SQL语句发出去）你想借哪本书。工作人员会先看看最近有没有别人借过完全一样的书（查询缓存）。
>
> - 如果最近有人借过，并且书还在，直接就把那本书给你了（命中缓存，直接返回结果）。
>
> - 如果没人借过或者书已经不在了（未命中缓存或缓存失效），工作人员需要先看看你写的书名、作者信息有没有错别字（分析器 - 词法分析和语法分析），确认你确实是要借一本存在的书。
>
> - 接着，工作人员需要决定怎么去书架上找这本书最快（优化器）。图书馆有很多书架，书可能放在不同的区域，优化器会根据书名、作者等信息，决定最佳的查找路径和顺序。
>
> - 决定好路径后，工作人员会按照计划去书架上执行查找任务（执行器）。他会先检查你是否有权限借这本书（权限校验），然后按照路径去书架区域（调用存储引擎），一本一本（以行为单位）地查找。
>
> - 最终，管理书架的区域（存储引擎）会负责找到这本书并交给工作人员（执行器），工作人员再把书交给你。"

#### 1. 连接器（Connection）

> 首先是连接器，它负责`监听客户端的请求`与MySQL服务器建立连接，验证用户名和密码。连接建立后，连接器维护这个连接会话。

#### 2. 查询缓存（Query Cache）

> 连接器收到SQL语句后，会先到查询缓存中查找是否有完全相同的语句。尝试直接返回之前执行过的SQL语句及其结果。
>
> MySQL会以Key-Value的形式缓存之前执行过的SQL语句，Key是SQL语句本身，Value是查询结果。
>
> 重要提醒：不过需要注意的是，查询缓存在MySQL 8.0之后已经被`移除`了，因为它的失效机制是表级别的，只要数据表有任何更新，所有相关的缓存都会被清空，在高并发场景下缓存命中率很低，反而影响性能。查询缓存虽然被移除了，但我们可以在应用层加一个数据中间件Redis等缓存来解决类似问题

#### 3. 分析器（Parser）

>  如果查询缓存未命中，SQL语句会发送给分析器进行词法分析和语法检查，最后构建一个内部的解析树，理解这个语句的意图
>
> - 词法分析：识别SQL语句中的关键字，如SELECT、FROM、WHERE等
> - 语法分析：判断SQL语句是否符合语法规范，理解语句的具体含义，比如是查询、更新还是删除操作

#### 4. 优化器（Optimizer）

> 分析器确认语句无误后，交给优化器评估多种可能的执行方案
>
> 比如：是全表扫描然后过滤？还是利用字段上的索引？如果有多个索引可用，用哪个索引效率最高？如果涉及多表查询，先查哪个表？优化器会根据统计信息和规则，选择一个它认为成本最低（执行最快）的执行计划。
>
> 这里要特别注意：MySQL的优化器并不是完美的，有时候我们需要通过hint或者调整SQL写法来`引导优化器`做出正确选择。我们可以通过EXPLAIN命令来查看执行计划。

#### 5. 执行器（Executor）

> 优化器生成执行计划后，交给执行器检查当前用户是否有操作目标表的权限，放行后按照优化器制定的执行计划，以行为单位调用存储引擎接口。
>
> 比如，如果计划是走age索引，执行器就会调用存储引擎的索引查找接口，找到年龄大于18岁的主键值，然后通过主键索引回表获取完整的行数据；如果是全表扫描，执行器就会调用存储引擎的接口，逐行读取users表的所有数据，然后执行器会判断每一行的age是否大于18，符合条件的行才返回。

#### 6. 存储引擎（Storage Engine）

> 存储引擎（如InnoDB）接收到执行器的指令后，负责实际的数据读写操作，从磁盘或内存中获取数据，并返回给执行器。
>
> 不同的存储引擎（InnoDB、MyISAM等）有不同的实现机制，比如InnoDB支持事务，而MyISAM不支持。
>
> 在实际工作中，我们主要关注优化器和执行器这两个环节，通过合理的索引设计和SQL优化来提升查询性能。

> 在我的工作中当遇到一个查询特别慢时，我首先就会想到是不是索引没用好，或者优化器选择了错误的执行计划。这时，我就会使用EXPLAIN命令去查看这条SQL的执行计划，分析它是走的哪个索引（或没有走索引）、扫描了多少行数据、连接表的顺序是否合理等等。EXPLAIN的输出其实就是优化器生成并交给执行器的'工作清单'。通过分析这个清单，我就能定位问题，比如是需要创建新的索引、调整SQL写法来'引导'优化器，还是数据量太大需要考虑分库分表。另外，对于MySQL 8.0之前的版本，关闭查询缓存（query_cache_type=0）几乎是一个标准操作，因为在高并发写多的场景下，它的收益远小于维护成本和锁竞争开销，不如在应用层使用Redis等更灵活的缓存方案。