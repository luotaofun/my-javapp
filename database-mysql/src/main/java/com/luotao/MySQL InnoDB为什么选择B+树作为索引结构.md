## MySQL InnoDB为什么选择B+树作为索引结构?

> 我们知道，数据库的数据最终是存储在磁盘上的。相比于内存访问，磁盘I/O的速度要慢得多。索引存在的目的，就是为了减少数据库在查找数据时进行的磁盘I/O次数。
>
> 在B+树之前，有很多查找数据结构，比如：
>
> - 简单的二叉查找树 (BST) 或 平衡二叉树 (如AVL树)： 这些树在内存中表现很好，查找效率是O(log N)。但它们的节点通常只存储一个数据项或一个键值，这导致树的层高可能比较大。在磁盘上，每次访问一个节点可能就需要一次磁盘I/O。如果树很高，查找一个数据就需要多次随机磁盘读，这在磁盘上是非常慢的。
>
> - B树： B树是对这些树结构的改进，它的每个节点可以存储多个键值和多个子节点的指针，并且节点本身也可以存储数据。这样做的好处是，一次磁盘I/O可以读取一个更大的节点（通常一个节点的大小设计成一个磁盘页例如16KB），这样树的层高就大大降低了，减少了查找时的磁盘I/O次数。B树已经比较适合磁盘存储了。
>
> 而B+树在B树的基础上，又做了进一步的优化，这些优化让它更适合作为数据库索引：
>
> - 非叶子节点只存储键值和指针： 与B树不同，B+树的非叶子节点只存放用于索引的键值和指向子节点的指针，不存储实际的数据行。这使得一个非叶子节点可以存储更多的索引项，从而进一步压缩了树的高度。树越矮，查找一个键所需的磁盘I/O就越少，可以快速从根结点沿着分支找到对应的叶子结点。
>
> - 所有数据都存储在叶子节点： B+树的所有数据记录都存储在树的最底层的叶子节点上。
>
> - 叶子节点之间形成有序链表：所有的叶子节点会按照键值的顺序，通过一个链表连接起来。比如，查找年龄在20到30岁之间的所有用户，只需要先通过索引找到范围的起始点20对应的叶子节点，然后就可以沿着叶子节点之间的链表顺序遍历，直到找到范围的结束点。这个过程避免了回到上层节点重新查找，大大提高了范围查询的效率
> - B+树节点的大小通常设计为和磁盘页（如16KB）一样大，这样每次读写一个节点，正好对应一次完整的磁盘页操作，充分利用了磁盘的预读能力
>
> 打个比方： 想象一下图书馆的索引卡片目录（非叶子节点）和实际存放书的货架（叶子节点）。B+树的索引卡片目录只告诉你这本书在哪一排（指向子节点的指针），而真正的书都在最后一层的货架上。而且，同一层货架上的书是按照书名（键值）排好序的，并且每个货架都告诉你下一排货架在哪里（叶子节点链表）。
>
> 我自己的项目之前也做过一些数据库性能优化。当遇到慢查询时，首先就会想到检查SQL语句是否使用了合适的索引。通过EXPLAIN命令查看执行计划，我们能看到MySQL是否走了索引，走了哪个索引，以及索引的使用方式（比如是全索引扫描还是范围扫描）。理解底层是B+树，就能帮助我们分析为什么某个索引有效或无效，比如一个组合索引，如果查询条件没有包含索引的最左前缀，B+树的特性就可能导致索引失效。

补充：

- 线性查找： 简单直观，但在大量数据面前效率极低（O(n)）。
- 二分查找： 基于有序数据，效率大大提高（O(log n)），但需要数据连续存放，不适合磁盘随机读写。
- 二叉查找树 (BST)： 树形结构，查找效率理论上也是 O(log n)，解决了数据不必连续存放的问题。但存在树不平衡的问题，极端情况下会退化成链表，效率又回到 O(n)。
- 平衡二叉树 (AVL)： 在BST基础上,增删改时引入了旋转操作维护树的平衡，保证不会退化成链表，查找效率稳定在 O(log n)。
