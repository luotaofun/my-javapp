# MySQL索引

## 索引选择与干预

* **查询优化器（Query Optimizer）**：优化器会估算每个物理查询计划的执行成本（包括 I/O 成本、CPU 成本等）。索引基数是估算 I/O 成本的重要依据，因为基数越大，意味着通过索引可以过滤掉更多的数据，减少需要读取的数据页。

* **索引基数（Cardinality）**：优化器做决策的关键参考指标。它表示索引列中不重复值的数量。基数越大，说明该列的唯一性越高，索引的区分度越好，通过索引过滤出的数据量就越少，查询效率通常越高。MySQL 会通过抽样统计的方式来估算这个基数，可能“选错”索引。

  > 例如，我们有一个日志表，某个 `status` 字段虽然建了索引，但因为数据分布不均（比如 99% 的记录 `status` 都是 'SUCCESS'），导致优化器认为这个索引的区分度很低，反而选择了全表扫描。
  >
  > 1.  **强制使用索引（`FORCE INDEX`）**：如果我通过 `EXPLAIN` 分析后，确定某个索引明明更高效，但优化器没有选择，我就会在 SQL 语句中使用 `FORCE INDEX(index_name)` 来强制 MySQL 使用我指定的索引。
  > 2.  **重新统计索引信息（`ANALYZE TABLE`）**：如果索引基数估计明显失误，导致优化器持续做出错误选择，使用 `ANALYZE TABLE table_name` 命令来强制 MySQL 重新收集并更新表的统计信息。这通常能让优化器更准确地估算索引基数，从而在后续查询中做出更明智的索引选择。在数据量有较大变动或者数据分布发生显著变化后，定期执行 `ANALYZE TABLE` 对保持查询性能非常重要。

* **统计信息（Statistics）**：MySQL 维护着关于表和索引的统计信息，包括索引基数、数据分布等。这些信息是优化器进行成本估算的基础。

> 我们可以把 MySQL 的查询优化器想象成一个“路线规划师”。当我们要从 A 地到 B 地时，有很多条路可以选择（不同的索引）。这个规划师会根据每条路的“路况”（索引的区分度、数据量等）来估算哪条路最快（成本最低）。
>
> 比如，我们有一个用户表 `users`，里面有 `user_id`（主键）、`name`、`gender`、`city` 等字段。
>
> *   如果我们要查询 `SELECT * FROM users WHERE city = 'Beijing';`，并且 `city` 字段上有一个索引。
> *   优化器会评估这个 `city` 索引的“路况”，也就是它的**索引基数（Cardinality）**。如果 `city` 字段的取值非常多（比如有几万个不同的城市），那么这个索引的区分度就很高，优化器很可能会选择走这个索引。
> *   但如果 `city` 字段的取值很少（比如只有“北京”、“上海”两个城市），那么这个索引的区分度就很低，优化器可能会认为全表扫描反而更快，从而放弃使用这个索引。



## 联合索引的左侧原则

联合索引是使用两个或多个字段创建的索引。在实际工作中，我经常使用联合索引来优化查询性能。联合索引有一个重要的特性：**它按照最左侧字段优先排序**。

联合索引可以代替最左侧字段的单独索引。例如，如果已经有了(shop_name, floor)的联合索引，就不需要再单独为shop_name创建索引，因为联合索引已经能够加速对shop_name的查询。

举个例子，假设我们有一个商店信息表，创建了一个基于"商店名称"和"楼层"的联合索引：

```sql
CREATE INDEX idx_shop_floor ON shops(shop_name, floor);
```

这个联合索引的工作原理如下：

1. 索引首先按照商店名称排序
2. 对于商店名称相同的记录，再按照楼层排序

联合索引遵循"带头大哥不能死，中间兄弟不能丢"的原则：

1. **带头大哥不能死**：WHERE条件中必须包含最左侧字段
   - 有效：`WHERE shop_name = '麦当劳'`
   - 有效：`WHERE shop_name = '麦当劳' AND floor = 1`
   - 无效：`WHERE floor = 2`（不包含最左侧字段）

2. **中间兄弟不能丢**：如果跳过中间字段，后面的字段将无法使用索引
   - 在三字段索引(a,b,c)中，条件`WHERE a=1 AND c=3`无法完全利用索引，因为跳过了b

## 字符串前缀索引

对于长字符串字段，创建完整索引会占用大量空间。前缀索引是一种优化方案，只索引字符串的前几个字符。

前缀索引的关键是选择合适的前缀长度，确保有足够的区分度。如果前缀区分度太小，索引效果会大大降低。

例如，如果用身份证号作为索引，同一地区的人前几位都相同，前缀索引的区分度就会很低。解决方案有：

1. **倒序存储**：将字符串倒序存储，这样原来相似的前缀变成了不同的后缀
2. **哈希字段**：创建一个新的哈希字段，存储原字段的哈希值，然后对哈希字段建立索引

> 在我之前的项目中，我们遇到过需要索引员工邮箱的情况。由于公司邮箱都有相同的后缀（@company.com），索引整个邮箱字段会浪费空间。这时，我们可以使用前缀索引，只索引邮箱的前几个字符：
>
> ```sql
> CREATE INDEX idx_email ON employees(email(6));
> ```
>
> 这样就只使用邮箱的前6个字符作为索引，大大节省了索引空间。

## 左模糊查询

字符串的模糊查询对索引的影响很大：

1. **全模糊查询**：`LIKE '%keyword%'` - 索引失效
2. **右模糊查询**：`LIKE '%keyword'` - 索引失效
3. **左模糊查询**：`LIKE 'keyword%'` - 可以使用索引

这是因为索引是从左到右排序的，就像字典中的单词一样。当我们不确定字符串的开头时（使用前置%），数据库无法利用索引的排序特性。

在处理需要全模糊查询的大数据量场景时，建议使用专门的搜索引擎，如MySQL的FULLTEXT索引或Elasticsearch，而不是依赖普通索引。

## 覆盖索引

覆盖索引（Covering Index）简单来说，当一个查询语句所需要的所有数据（包括 SELECT 列表中的字段和 WHERE 条件中的字段）都能从一个索引中直接获取，而无需回表查询主键索引或数据行时，这个索引就被称为覆盖索引。覆盖索引通过避免回表操作，减少了磁盘I/O（因为索引通常比数据表小，更容易加载到内存，并且访问索引的随机I/O也变成了对索引的顺序/局部访问）。

> 应用场景：比如我们有一个商品库存表 inventory，里面有 store_id（店铺ID）、film_id（影片ID）、inventory_id（库存ID，主键）和 last_update（最后更新时间）等字段。
>
> 假设我们经常需要根据 store_id 查询 store_id 和 film_id。如果我们为 (store_id, film_id) 创建了一个联合索引。当执行 SELECT store_id, film_id FROM inventory WHERE store_id = 1; 这样的查询时，MySQL 发现这个联合索引已经包含了所有需要查询的字段 (store_id 和 film_id)，并且 WHERE 条件中的 store_id 也是索引的前缀部分，可以直接利用这个索引进行查找和返回结果，无需再去访问表中的实际数据行。这时，这个联合索引就起到了覆盖索引的作用。
>
> 一些慢查询问题。通过 EXPLAIN 分析发现，很多查询虽然用到了索引，但 Extra 列并没有显示 Using index，而是需要回表。
>
> 例如，一个查询 SELECT col1, col2, col3 FROM my_table WHERE col1 = 'value'; 如果我们只有一个 col1 的单列索引，那么在找到匹配 col1 的记录后，还需要回表去获取 col2 和 col3。后来，我们根据查询的实际需求，将 col1 的索引调整为一个包含 (col1, col2, col3) 的联合索引。调整后，再次 EXPLAIN 这个查询，Extra 列就显示了 Using index，查询性能得到了显著提升。
>
> 当然，创建覆盖索引也需要权衡。虽然它能提升查询性能，但索引本身也需要占用存储空间，并且在数据写入（INSERT, UPDATE, DELETE）时会增加维护索引的开销。因此，我们会优先为那些查询频繁、对性能要求高的场景创建覆盖索引，并且只包含必要的列，避免创建过多冗余或过宽的索引。比如，避免无脑 SELECT *，因为它几乎不可能利用到覆盖索引，除非索引包含了表中的所有列，但这通常是不现实的。

索引结构：B+ 树结构。
包含的列：这个索引必须包含查询语句中 SELECT 子句请求的所有列，以及 WHERE 子句中用到的所有列。
查询语句：查询语句的 SELECT 和 WHERE 部分与索引列的匹配程度决定了是否能形成覆盖索引。
作用在于，当查询命中覆盖索引时，MySQL可以直接从索引的叶子节点获取所需数据，避免了“回表”操作。回表是指在通过辅助索引找到主键值后，还需要根据主键值再次去主键索引（聚簇索引）中查找完整的数据行。

当一个 SQL 查询到达 MySQL 时：

1. 解析与优化：MySQL 解析器会分析 SQL 语句，查询优化器会评估不同的执行计划。

2. 索引选择：优化器会判断是否存在合适的索引。如果发现某个索引包含了查询所需的所有列（SELECT 和 WHERE 中的列）。

3. 数据检索：

   * 使用覆盖索引：如果确定可以使用覆盖索引，MySQL 会直接在该索引的 B+ 树中进行查找。一旦定位到符合 WHERE 条件的索引条目，由于这些条目已经包含了 SELECT 所需的所有数据，MySQL 就直接从索引中提取这些数据并返回给客户端。这个过程中，它不需要再根据索引中的主键值去主表（聚簇索引）中查找完整的行记录。

   * 不使用覆盖索引（需要回表）：如果索引不包含所有 SELECT 的列，即使 WHERE 条件可以用到索引，MySQL 在通过该辅助索引找到数据行的主键后，还需要进行一次额外的“回表”操作，即根据主键去主键索引中查找完整的行数据，然后从中提取 SELECT 所需的列。

4. 结果返回：将检索到的数据返回给用户。

通过 EXPLAIN 命令查看执行计划时，如果 Extra 列显示 Using index，就表明该查询成功使用了覆盖索引。
