# 公平锁与非公平锁

> 在实际开发中，非公平锁是更优的选择。例如，ReentrantLock` 默认就是非公平的，`synchronized` 关键字实现的也是非公平锁。这是因为在大多数高并发场景下，**吞吐量**往往比严格的**公平性**更为重要。虽然非公平锁存在线程饥饿的风险，但在实际应用中，这种风险通常可以通过其他机制（如线程调度器、任务队列等）来缓解。

公平锁和非公平锁是并发编程中，对多个线程请求同一把锁时，获取锁的策略的两种不同实现。

*   **等待队列（Waiting Queue）**：当多个线程竞争同一把锁而未能立即获取时，它们会被放入一个等待队列中。
*   **锁的获取机制**：
    *   **公平锁**：在锁被释放时，会检查等待队列。如果队列中有线程在等待，那么锁会严格地交给队列头部的线程。每个线程都有机会执行。性能开销相对较大。因为每次释放锁后，都需要进行上下文切换，唤醒等待队列中的线程，这会带来额外的 CPU 消耗。吞吐量相对较低。
    *   **非公平锁**：在锁被释放时，它会尝试让当前正在请求锁的线程（可能是刚释放锁的线程，也可能是新来的线程）立即获取锁，而不会优先检查等待队列。只有当这种“插队”尝试失败（比如没有线程立即请求，或者请求的线程需要被唤醒且成本较高）时，才会去检查等待队列。性能开销相对较小，吞吐量更高。因为它允许“插队”，减少了不必要的上下文切换和线程唤醒开销。

> *   **公平锁**：就像在火车站售票窗口排队，每个人都按照到达的先后顺序依次购票。第一个人买完，第二个人才能买，以此类推。没有人可以插队。
> *   **非公平锁**：就像在售票窗口，第一个人买完票走了，队伍里的第二个人正准备上前，但此时突然有一个人迅速地插队买了一张票。虽然队伍里有人在等，但因为这个“插队者”获取锁的成本极低（甚至没有阻塞），所以他被允许优先获取锁。

以 `ReentrantLock` 为例（默认是非公平锁，但可以设置为公平）：

*   **线程请求锁**：
    1.  线程尝试获取锁。
    2.  如果锁当前没有被任何线程持有，或者当前线程就是持有锁的线程（可重入），则直接获取成功。
    3.  如果锁被其他线程持有：
        *   **非公平锁**：当前线程会先尝试“抢占”一下锁。如果抢占成功（通常发生在锁刚被释放，且当前线程没有进入阻塞状态时），则获取成功。如果抢占失败，或者锁被其他线程持有，则线程会进入等待队列。
        *   **公平锁**：当前线程会先检查等待队列。如果队列为空，则尝试获取锁；如果队列不为空，则线程会直接进入等待队列排队，即使锁当前是空闲的。
*   **线程释放锁**：
    1.  持有锁的线程释放锁。
    2.  锁释放后，会唤醒等待队列中的一个或多个线程（通常是队列头部的线程）。
*   **被唤醒线程获取锁**：被唤醒的线程会再次尝试获取锁。在公平模式下，被唤醒的线程通常会成功获取锁；在非公平模式下，被唤醒的线程可能需要再次竞争，甚至可能被其他“插队”的线程抢先。
