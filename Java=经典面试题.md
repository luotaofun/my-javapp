## QPS

> `query per second` 即每秒请求数,一般`2000次`可满足大多业务场景
>
> 记录`QPS`的两种方式:
>
> * 在接口方法中用唯一字符串日志记录,然后统计字符串出现的次数
> * 用`Tomcat access log`记录接口访问日志,然后统计日志出现的次数

## 工作流

> 将业务流程定义为一系列节点和连接,在多个参与者之间按预定规则自动传递信息或任务,用户只需要用可视化的方式定义好流程的各个步骤\规则和参与者,如添加"订单组审核"节点只需在流程定义中添加一个节点即可
>
> 提供对流程执行状态的实时监控,可以跟踪每个节点的进展,识别潜在问题并采取干预措施

## 成员变量与局部变量的区别

> 这就像是一个公司和临时工的关系：
>
> \- 成员变量就像是公司的正式员工，只要公司存在，他们就一直在那里
>
> \- 局部变量就像是临时工，只在特定项目期间存在，项目结束就离开了
>
> * 成员变量在堆中在对象被创建时根据数据类型赋默认值,与对象同生共死，对象被创建时分配内存，对象被垃圾回收时释放内存
>
> * 在使用前必须显式初始化。局部变量在栈内存作用于方法执行期间,方法结束后立即从栈中弹出。

## `final`修饰为什么不可变？

> * 修饰基本数据类型变量时（常量）则其值一旦初始化后就不能再改变。
> * 修饰引用数据类型变量时则其引用不能再指向其他对象，但对象本身的内容是可以改变的（除非该对象本身是不可变的，如 `String`）。
> * 修饰的方法不能被子类override，从而保证方法的行为在继承体系中保持一致。
> * 修饰的类不能被继承，这就像是一个完美的产品设计，设计师认为它已经达到了最佳状态，不需要也不允许任何修改或扩展。。
> * `final` 提供了一种机制来保护数据或行为不被意外或恶意修改，特别是在多线程环境或第三方库使用场景中。
> * 编译器可以对`final`方法进行内联优化

## `ThreadLocal`

> 进程是计算机资源分配最小单位，线程是计算机计算的最小单位。这个最小的计算单位在操作系统中由进程去控制，所以操作系统只负责把资源分配给进程，进程没有专门空间存储`ThreadLocal`,所以它跟多是语言层面的事情。`ThreadLocal`提供线程局部变量，相当于给每一个线程独立的副本。
>
> 比如你在玩游戏，一个游戏就是进程。这个进程用于有渲染的程序A，和有用于AI处理的程序B。A和B经常抢占`CPU`的时间片就会导致游戏卡顿。如果一个进程中的所有线程在同步计算结果时去访问进程中的全局变量，就会产生竞争条件，需要解决一致性（加锁）。

## `@Autowired`与`@Resource`的区别

> `@Autowired `注解的作用就是让 `Spring `容器自动为 `areaDao `成员变量注入一个实现了 AreaDao 接口的实例对象。`Spring` 会根据配置（例如 `MyBatis `的配置）动态生成`AreaDao` 实现类的代理对象。这个代理对象会被注入到 `areaDao` 中
>
> `@Autowired`根据type注入，@Resource基于名称，找不到时基于类型注入，本质上均实现了注入效果。
> 一般来说，注入controller的service虽然一般来说我们都是注入一个接口，但是该接口有实现类，并且使用`@Service`进行关联，所以注入类型应该也可以视为一个类，但是`mybatis`仅需提供Dao接口，也就是说，注入`service`的`dao`只是一个接口，而没有实现类，虽然`mybatis`能够通过Dao接口和xml文件实现与数据库的操作，但是`@Autowired`并没有这个识别功能，可能它就认为你类型不匹配，无法使用通过类型注入的方法



## 无状态登录

> 传统的登录验签：
>
> 服务器校验完账号密码后用httpsession生成sessionid，把sessionid回写到浏览器的cookie，下次请求时浏览器会自动携带这个cookie,对cookie进行拦截即可判断是否放行。
>
> 无状态登录验签：
>
> 支持CS和BS架构，狐表开发的应用没有管理session cookie的功能，所以不得不使用无状态登录方式。服务端把令牌生成并返回给客户端后，可能产生安全隐患，比如用户账密泄露被第三方登录了，并且密码被修改了，这时候，一般情况是只要用户修改账密，就应该把这个用户所有账号踢下线，但是由于之前签发的令牌没有过期，那就可以一直请求放行。
>
> 基于Redis：
>
> 1. 只做存取和匹配。这样不用去加解密，因为加解密本身是很耗CPU的行为。
> 2. 对权限可观可控。当用户修改账密后，可以在Redis把对应令牌删除，实现重登录。

# spring

* 聊聊spring

  > ioc容器是spring的`基石`，用来`承载`bean对象。它的数据结构是map，比如三级缓存用到了ConcurrentHashMap和hashmap。把beanName作为key，bean实例对象作为value，在创建iocContainer后我们可以通过
  >
  > context.getBean(Class,String)来获取bean对象。
  >
  > 创建对象的方式有：new、工厂、反射，那spring如何去创建bean对象？
  >
  > 1. 配置xml文件提前定义好bean对象的描述信息
  >
  >    ```xml
  >    <bean id=? class=? scope init-method abstract>
  >    <property name=? value=?>
  >    <property name=? ref=?>
  >    </bean>
  >    ```
  >
  > 2. 通过new ClassPathXmlApplicationContext("xml文件")把bean定义信息读到ioc容器中（BeanDefinition接口） 
  >
  > 

  

* bean的生命周期

* 循环依赖

* 三级缓存

* FactoryBean和beanFactory

* applicatiContext和BeanFactory的区别

* 设计模式

## Cookie、Session和Token的区别？

> 发一个登录请求把账密传到服务器，服务器进行鉴权后将账密传到前端，前端将账密保存到cookie，那后续的请求都带上cookie，这样就维持了用户的登录状态。cookie存储在浏览器有被篡改的风险，所以我们不能完全依赖cookie。
>
> 我们可以通过在服务器鉴权后，将Session存入用户信息，响应时Tomcat会自动在响应头存入将SessionId存入setcookie，浏览器发现响应头包含setcookie这个属性就会自动将SessionId存入cookie，那么后续的请求也会携带cookie，服务器拿到cookie中的SessionId就可以得到登录的用户信息维持登录状态。由于Session保存在服务端，所以安全性高，但是如果服务器压力比较大，对服务器进行集群部署，那Session只会存在一台服务器上，其他服务器并不会有当前的用户登录信息，如果集群之后负载均衡，有可能下一次的请求就会打到其他服务器，那就会鉴权失败，现在基本都是前后端分离的架构，也会导致跨域，我们需要在前后端都去设置运行跨域，非常麻烦。
>
> JsonWebToken生成的Token字符串有三部分组成：
>
> - header：包含了加密的算法和Token类型，将这些信息base64编码后得到Token的第一部分
> - payload负载数据：将包含我们需要传递的信息，比如账密，将这些信息base64编码后得到Token的第二部分 ，前端可以对其base64解码
> - signature签名：将base64编码的header和payload相加，再加上我们的私钥，最后再通过header中的加密算法加密就构成了Token的第三部分
>
> 在服务器鉴权成功后会创建一个JWT的Token字符串，包含这三段信息，然后把Token返回给前端，前端对其字符截取然后base64解码后拿到payload，后续的请求只需在请求头中携带Token，后端拿到Token后解密验证signature，如果没有被篡改则放行，整个过程不需要依赖前后端的任何存储，就是一个加密后的字符串。